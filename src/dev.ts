import { walk, WalkEntry, WalkOptions } from "$std/fs/walk.ts";
import { join, normalize } from "$std/path/mod.ts";

/** HELPERS **/

type Template = {
  root: string;
  imports: {
    file: string;
    name: string;
  }[];
  routes: {
    file: string;
    value: string;
  }[];
};

async function collect(
  dir: URL,
  options?: WalkOptions,
): Promise<WalkEntry[]> {
  const entries: WalkEntry[] = [];

  // Remove the extraneous Deno.readDir when
  // https://github.com/denoland/deno_std/issues/1310 is fixed.
  for await (const _ of Deno.readDir(dir)) {
    // do nothing
  }

  const routesFolder = walk(dir, options);
  for await (const entry of routesFolder) {
    if (!entry.isFile) continue;
    entries.push(entry);
  }

  return entries
    .sort((a, b) => a.path.localeCompare(b.path))
    .map((entry) => ({
      ...entry,
      path: entry.path.slice(dir.pathname.length),
    }));
}

async function writeLazy(path: string | URL, source: string) {
  try {
    const current = await Deno.readTextFile(path);
    if (current === source) return;
  } catch (error) {
    if (!(error instanceof Deno.errors.NotFound)) throw error;
  }

  await Deno.writeTextFile(path, source);
}

async function formatTypescript(source: string) {
  const proc = new Deno.Command(Deno.execPath(), {
    args: ["fmt", "-"],
    stdin: "piped",
    stdout: "piped",
  }).spawn();

  const raw = new ReadableStream({
    start(controller) {
      controller.enqueue(new TextEncoder().encode(source));
      controller.close();
    },
  });
  await raw.pipeTo(proc.stdin);
  const { stdout, success } = await proc.output();

  if (!success) throw new Error("Failed to format TypeScript.");

  return new TextDecoder().decode(stdout);
}

function toTemplate(root: string, entries: {
  path: string;
}[]): Template {
  const scriptExtensions = [".js", ".ts", ".tsx", ".jsx"];

  const template: Template = {
    root,
    imports: [],
    routes: [],
  };

  for (const entry of entries) {
    const { path } = entry;
    const file = "./" + normalize(join(root, path));
    const isScript = scriptExtensions.some((ext) => file.endsWith(ext));
    if (isScript) {
      const varName = `$${template.imports.length}`;
      template.imports.push({
        file: file,
        name: varName,
      });
      template.routes.push({
        file,
        value: varName,
      });
    } else {
      template.routes.push({
        file,
        value: "null",
      });
    }
  }

  return template;
}

const stringifyTemplate = ({ root, imports, routes }: Template) => `
// DO NOT EDIT. This file is generated by litdoc.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running \`dev.ts\`.

${
  imports
    .map((item) => `import * as ${item.name} from "${item.file}";`)
    .join("\n")
}

export default {
  baseUrl: import.meta.url,
  root: "${root}",
  routes: {
    ${
  routes
    .map((item) => `    "${item.file}": ${item.value},`)
    .join("\n")
}
  },
};
`;

/** MAIN **/

export default async function dev(metaUrl: string | URL, options: {
  root?: string;
  skip?: RegExp[];
  match?: RegExp[];
  exts?: string[];
}) {
  const { root = "./", skip, match, exts } = options;

  const baseUrl = new URL("./", metaUrl);
  const rootUrl = new URL(root, baseUrl);

  let entries: WalkEntry[];
  try {
    entries = await collect(rootUrl, {
      match,
      skip,
      includeDirs: false,
      includeSymlinks: false,
      exts,
    });
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      console.log(
        `%cBase URL ${baseUrl} does not exist. Skipping manifest generation.`,
        "color: yellow; font-weight: bold",
      );
      return;
    } else {
      throw err;
    }
  }

  const template = toTemplate(root, entries);
  const raw = stringifyTemplate(template);
  const formatted = await formatTypescript(raw);
  await writeLazy("litdoc.gen.ts", formatted);

  console.log(
    `%cThe manifest has been generated for ` +
      `${template.routes.length} routes.`,
    "color: green; font-weight: bold",
  );
}
