import type {
  WalkEntry,
  WalkOptions,
} from "https://deno.land/std@0.194.0/fs/walk.ts";
import { walk as walkImpl } from "https://deno.land/std@0.194.0/fs/walk.ts";
import { stringify, tagged } from "./templates.ts";

/** HELPERS **/

type Value = (routes: Record<string, unknown>) => string[];

type CollectEntry = WalkEntry & {
  id: string;
  varName: string;
};

type Index = Record<string, CollectEntry>;

type IndexMap<T> = {
  [key in keyof T]: Index;
};

async function walk(
  dir: URL,
  options?: WalkOptions,
): Promise<WalkEntry[]> {
  const entries: WalkEntry[] = [];
  try {
    // TODO(lucacasonato): remove the extraneous Deno.readDir when
    // https://github.com/denoland/deno_std/issues/1310 is fixed.
    for await (const _ of Deno.readDir(dir)) {
      // do nothing
    }
    const routesFolder = walkImpl(dir, options);
    for await (const entry of routesFolder) {
      entries.push(entry);
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      console.log(`No such file or directory '${dir}'`);
      // Do nothing
    } else {
      throw err;
    }
  }
  return entries
    .sort((a, b) => a.path.localeCompare(b.path))
    .map((entry) => ({
      ...entry,
      path: entry.path.slice(dir.pathname.length),
    }));
}

async function collect<T>(
  baseUrl: URL,
  config: {
    [key in keyof T]: WalkOptions;
  },
): Promise<IndexMap<T>> {
  const indexes: Partial<IndexMap<T>> = {};

  let varId = 0;
  const lookup: Record<string, CollectEntry> = {};

  for (const key in config) {
    const options = config[key];
    const entries = await walk(baseUrl, options);

    const index: Index = {};

    for (const entry of entries) {
      if (lookup[entry.path] == null) {
        const varName = `$${varId++}`;
        const collectEntry: CollectEntry = {
          ...entry,
          id: entry.path,
          varName,
        };
        lookup[entry.path] = collectEntry;
      }
      index[entry.path] = lookup[entry.path];
    }

    indexes[key] = index;
  }
  return indexes as IndexMap<T>;
}

async function writeLazy(path: string | URL, source: string) {
  try {
    const current = await Deno.readTextFile(path);
    if (current === source) return;
  } catch (error) {
    if (!(error instanceof Deno.errors.NotFound)) throw error;
  }

  await Deno.writeTextFile(path, source);
}

async function formatTypescript(source: string) {
  const proc = new Deno.Command(Deno.execPath(), {
    args: ["fmt", "-"],
    stdin: "piped",
    stdout: "piped",
    stderr: "null",
  }).spawn();

  const raw = new ReadableStream({
    start(controller) {
      controller.enqueue(new TextEncoder().encode(source));
      controller.close();
    },
  });
  await raw.pipeTo(proc.stdin);
  const { stdout } = await proc.output();

  return new TextDecoder().decode(stdout);
}

const template = tagged<Value>`
// DO NOT EDIT. This file is generated by litdoc.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running \`dev.ts\`.

${((routes) =>
  Object.keys(routes)
    .map((file, i) => `import * as ${"$" + i} from "./${file}";`))}

export default {
  baseUrl: import.meta.url,
  routes: {
    ${(routes) =>
  Object.keys(routes)
    .map((file, i) => `"./${file}": ${"$" + i},`)}
  },
};
`;

/** MAIN **/

export default async function dev(metaUrl: string, options: {
  routes: WalkOptions;
}) {
  const baseUrl = new URL("./", metaUrl);

  const { routes } = await collect(baseUrl, {
    routes: {
      includeFiles: true,
      ...options.routes,
    },
  });

  const raw = stringify(
    template,
    (value) => value(routes).join(""),
  );

  const formatted = await formatTypescript(raw);
  await writeLazy("litdoc.gen.ts", formatted);

  console.log(
    `%cThe manifest has been generated for ` +
      `${Object.keys(routes).length} routes.`,
    "color: green; font-weight: bold",
  );
}
